## 运行时数据区域

**JDK 1.8 之前：**

![image-20200824150622539](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200824150622539.png)

**JDK 1.8 ：**

![image-20200824150654275](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200824150654275.png)

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

### 2.1 程序计数器

**程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

**从上面的介绍中我们知道程序计数器主要有两个作用：**

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

**注意：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

### 2.2 Java虚拟机栈

每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

> 局部变量表是变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
>
> 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 / 入栈操作（例如：在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的）。
>
> 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用

该区域可能抛出以下异常：

- 当线程请求的栈深度超过最大值，**会抛出 StackOverflowError 异常**；
- 栈进行动态扩展时如果无法申请到足够内存，**会抛出 OutOfMemoryError 异常**。

### 2.3 本地方法栈

**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

### 2.4 堆

所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。

### 2.5 方法区

用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。

### Java8中，使用元空间替换永久代的原因

HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

### 2.6 运行时常量池

运行时常量池是方法区的一部分。

Class 文件中的常量池（编译器生成的**字面量和符号引用**）会在类加载后被放入这个区域。

#### 2.7 直接内存

JDK1.4引入的Nio包下，DirectByteBuffer分配对外内存，减少堆内堆外内存拷贝

