## Java内存模型(JMM)

计算机硬件内存模型，为了解决CPU和内存访问的几个数量级的差别，加入了高速缓存。

Java 内存模型**试图屏蔽各种硬件和操作系统的内存访问差异**

Java内存模型，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）[其实就是主内存中的变量]的访问方式。

JVM运行程序的实体是线程，而**每个线程**创建时JVM都会为其创建一个**工作内存**(有些地方称为栈空间)，用于**存储线程私有的数据**，而Java内存模型中规定所有**共享变量都存储在主内存**，主内存是**共享内存区域**，**所有线程都可以访问**，但线程**对变量的操作**(读取赋值等)必须**在工作内存中进行**，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝。

> JMM与java内存区域两者基本没有关系，如果一定要勉强对应，**主内存主要对应Java堆中的对象实例数据部分，也包括了共享的类信息、常量、静态变量**，工作内存则对应虚拟机栈的部分区域。

- **主内存**：主要存储的是**Java实例对象**，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然**也包括了共享的类信息、常量、静态变量**。共享数据区域，**多条线程对同一个变量进行访问可能会发现线程安全问题。**
- **工作内存**：主要存储**当前方法的所有本地变量信息**(工作内存中存储着**主内存中的变量副本拷贝**)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的。

JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的

### 原子性

操作是不可中断的，要做一定做完，要么就没有执行。

### 可见性

可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。

### 有序性

JMM是允许编译器和处理器对指令重排序的，不会影响到单线程的执行，但是在多线程中却容易出问题。

## JMM解决方案

原子性问题，除了JVM自身提供的对基本数据类型读写操作的原子类外，对于方法级别或者代码块级别的原子性操作，可以使用synchronized关键字或者重入锁(ReentrantLock)保证程序执行的原子性

可见性问题，可以使用synchronized关键字或者volatile关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。

有序性问题，则可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化

除了关键字，还有一套happens-before原则保证多线程下，两操作的原子性、可见性、有序性。

### happens-before

- 单一线程原则

- 锁原则

  加锁操作一定发生在同一锁下解锁过程之后

- volatile原则

  对于 volatile 变量的写操作先行发生于后面对这个变量的读操作（简单理解，v**olatile变量**在每次**被线程访问**时，都**强迫从主内存中读该变量的值**，而当该变量**发生变化**时，又会强迫**将最新的值刷新到主内存**）

- 线程启动原则

  start操作先行发生于此线程每个动作

- 线程加入规则

  加入线程的结束先行发生于join方法的返回

- 线程中断原则

  对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

- 对象终结原则

  对象的初始化优先于对下的finalize()方法的开始

- 传递性

  操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。

## volatile的理解

volatile是JVM提供的轻量级的同步机制

1.保证可见性

2.保证有序性，禁止指令重排

3.不保证原子性（需要借助synchronized或者CAS)

### volatile可见性和有序性

- 可见性

  **当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存**

  **当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。**

  每个线程在将数据操作完**stroe**回主存之前，会加**lock**指令来锁定内存区域的缓存（缓存行锁定），根据MESI缓存一致性协议，总线通过侦听器发现数据被修改，会立即让其他线程工作内存中不一致的副本立即失效。

  等到当前线程将更改后的数据**write**回主存后，立即执行**unlock**指令。

- 有序性

  volatile关键字另一个作用就是禁止指令重排优化，

### volatile是如何实现禁止指令重排优化的？

volatile是采用“内存屏障”来实现禁止特定类型的处理器重排序

加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障，内存屏障会提供3个功能：

1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面
2. 它会强制将对缓存的修改操作立即写入主存
3. 如果是写操作，它会导致其他CPU中对应的缓存行无效

