#### 代理模式

给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。

![image-20200814182600613](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200814182600613.png)

#### 静态代理

静态代理对应的静态代理类由程序员自己编写，在编译后，会有实实在在的.class 文件生成。

缺点：

- 当接口新增方法时，代理类和被代理类都需要实现对应的方法
- 一个被代理对象对应一个代理类，**产生过多的代理类**/一个代理类实现多个接口，代理类庞大不宜维护

#### 动态代理

动态生成代理类是因为 JVM 的类加载机制决定的。根据接口或目标对象，计算出代理类的字节码，然后再加载到JVM中使用。

>  动态代理实现方式：一种是利用反射来实现代理类调用真实主题角色的逻辑。第二种是利用字节码库 ASM 来生成代理类，进行调用。

##### JDK实现方式

![image-20200814183634857](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200814183634857.png)

![image-20200814183646113](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200814183646113.png)

实现 InvocationHandler，实现invoke方法

DemoInvocationHandler 的 invoke 方法接收到 method、args 等参数后，进行一些处理，然后通过反射让被代理的对象 target 执行方法

![](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200814183923104.png)

通过Proxy类的newProxyInstance方法创建代理实例

![image-20200814184029292](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200814184029292.png)

##### CGLIB实现方式

继承了 MethodInterceptor，实现interceptor方法，用于方法的拦截回调

![image-20200814185232428](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200814185232428.png)

![image-20200814185608914](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200814185608914.png)

