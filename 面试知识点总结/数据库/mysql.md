## MyISAM和InnoDB区别

MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。

 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。

1. **是否支持行级锁** : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
2. **是否支持事务和崩溃后的安全恢复：** **MyISAM**不支持事务和崩溃恢复，**InnoDB** 提供事务支持和崩溃恢复
3. **是否支持外键：** MyISAM不支持，而InnoDB支持。
4. **是否支持MVCC** ：仅 InnoDB 支持。MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作，MVCC比单纯的加锁更高效

## 事务

事务是逻辑上的一组操作，要么都执行，要么都不执行。

- 原子性（Atomicity）：事务被视为不可分割的最小单元，要么全部执行提交，要么失败回滚
- 一致性（Consistency）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
- 隔离性（Isolation）：各并发事务之间互不干扰；
- 持久性（Durability）：一旦事务提交，事务执行结果会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

## 并发一致性问题

- 丢失修改：一个事务访问了某个数据，另一个事务也访问了这个数据，第一个事务进行了修改，另一个事务也进行了修改，这样第一个事务的修改结果就会丢失。
- 脏读：一个事务正在访问数据，并且对数据进行了修改，数据的修改还没有提交到数据库，另一个事务也访问了这个数据，然后使用了这个数据。
- 不可重复读：在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。

- 幻影读：事务一读取了某个范围的数据，事务二在该范围内插入数据，事务一再次读取之后和第一次读取结果不一致。

## 事务隔离级别

- READ-UNCOMMITTED(读取未提交)：允许读取未提交的数据，会导致，脏读，不可重复读，幻读

- READ-COMMITED(读取提交)：允许读取已提交的数据，可以解决脏读，不能解决不可重复读，幻读

- REPETABLEREAD(可重复读)：对同一字段多次读取结果是一致的，可以解决脏读，不可重复读，不可以解决幻读

  可重复读+next-key lock算法也可解决幻读

- SERIALIZABLE(可串行化)：最高的隔离级别，所有的事务依次逐个执行

> 怎么解决脏读、不可重复读、幻读这些问题呢？
>
> 其实有两种可选的解决方案： 
>
> - 方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁。 
> - 方案二：读、写操作都采用加锁的方式。

## 锁机制和InnoDB锁算法

![image-20200831213306335](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200831213306335.png)

**乐观锁与悲观锁**：

乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务；

悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁；.

**锁类型：**

- 互斥锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

![image-20200831212334584](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200831212334584.png)

**意向锁**：

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。

IS/IX的意义是为了解决表锁和行锁冲突，提高加表锁时的效率。

**MyISAM和InnoDB存储引擎使用的锁：**

- MyISAM采用表级锁(table-level locking)。
- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

**表级锁和行级锁对比：**

- **表级锁：** MySQL中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
- **行级锁：** MySQL中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

## **当前读与快照读**

**1、当前读：**即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取锁的事务释放锁；

使用当前读的操作主要包括：显式加锁的读操作与插入/更新/删除等写操作，如下所示：

```
select * from table where ? lock in share mode;
select * from table where ? for update;
insert into table values (…);
update table set ? where ?;
delete from table where ?;
```

> 注：
>
> - DELETE： 对一条记录做**DELETE操作**的过程其实是先在B+树中**定位到这条记录的位置**，然后**获取**一下这条记录的**X锁**，然后再**执行delete mark操作**。我们也可以把这个定位待删除记录在B+树中位置的过程看成 是一个获取X锁的锁定读。 
>
> - UPDATE： 
>
>   在对一条记录做UPDATE操作时分为三种情况：
>
>   -  如果**未修改**该记录的键值并且被更新的列占**用的存储空间在修改前后未发生变化****，则先在B+树中**定位到这条记录的位**置，然后再获取一下记录的**X锁**，最后在原记录的位置**进行修改操作**。其实 我们也可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。 
>   - 如果**未修改该记录的键值**并且至少有一个被更新的列**占用的存储空间在修改前后发生变化**，则先在B+树中**定位到这条记录的位置**，然后**获取**一下记录的**X锁**，将该**记录彻底删除掉**（就是把记录 彻底移入垃圾链表），最后再**插入一条新记录**。这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT操作提供的隐式锁进行保护。 
>   - 如果**修改了该记录的键值**，则相当于在**原记录上做DELETE操作之后再来一次INSERT操作**，加锁操作就需要按照DELETE和INSERT的规则进行了。 
>
> - INSERT： 一般情况下，**新插入一条记录的操作并不加锁**，设计InnoDB的大叔通过一种称之为**隐式锁**的东东来保护这条新插入的记录在本事务提交前不被别的事务访问

**2、快照读**：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；

InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；

## InnoDB中的行级锁

> 两段锁协议，加锁和解锁分两个阶段进行

### Record Locks

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

### Gap Locks

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

### Next-Key Locks

它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。

### 插入意向锁

gap锁区间插入，T1持有gap锁，所以T2和T3需要生成一个插入意向锁的锁结构并且处于等待状态。当T1提交后会把它获取到的锁都释放掉，这样T2和T3就能获取到对应的插入意向锁了

### 隐式锁

一个事务对新插入的记录可以不显式的加锁，由于事务id这个牛逼的东东的存在，相当于加了一个隐式锁，别的事务在对这条记录加S锁或者X 锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。

> 情景一：对于聚簇索引记录来说，有一个trx_id隐藏列，该隐藏列记录着最后改动该记录的事务id。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的trx_id隐藏列代表的的就是当 前事务的事务id，如果其他事务此时想对该记录添加S锁或者X锁时，首先会看一下该记录的trx_id隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个X锁（也 就是为当前事务创建一个锁结构，is_waiting属性是false），然后自己进入等待状态（也就是为自己也创建一个锁结构，is_waiting属性是true）。 .
>
> 情景二：对于二级索引记录来说，本身并没有trx_id隐藏列，但是在二级索引页面的Page Header部分有一个PAGE_MAX_TRX_ID属性，该属性代表对该页面做改动的最大的事务id，如 果PAGE_MAX_TRX_ID属性值小于当前最小的活跃事务id，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复情景一的做法。

## MVCC

### 版本链

- trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。
- roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。

也就是说，数据表中的一行记录，其实可能有多个版本(row)，每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个`roll_pointer`属性，可以将这些undo日志都连起来，串成一个链。

### ReadView

ReadView中主要包含4个比较重要的内容：

- m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。 
- min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。 
- max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。 
- creator_trx_id：表示生成该ReadView的事务的事务id。

有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

- **如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同**，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 
- **如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值**，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。 
- **如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值**，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。 
- **如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间**，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创 建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

所谓的`MVCC（Multi-Version Concurrency Control ，多版本并发控制）`指的就是在使用`读已提交（READ COMMITTD）、可重复读（REPEATABLE READ）`这两种隔离级别的事务在执行普通的SELECT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。

两个隔离级别的一个很大不同就是：`生成ReadView的时机不同`，

- READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView
- REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView

## SELECT *

### 优点

**SELECT 星号查询能大幅提升开发效率和减轻后续维护的时间**。

### 缺点

#### 磁盘IO

查询的字段越多，说明要读取的内容也就越多，因此会增大磁盘 IO 开销。

#### 内存

后端代码会把查询结果保存在变量中，对于无用的长字段，只会增加内存开销

#### 网络传输/带宽

试想一下，MySQL服务器读取了多余的字段，传输给项目所在服务器，大字段传输长时间占用连接，传输时间长，对两个服务器来是都是多余的压力

#### 无法高效使用索引

对于非聚簇索引，尽量使用覆盖索引，而避免使用*导致回表。