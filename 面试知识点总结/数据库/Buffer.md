### Buffer Pool

磁盘太慢，用内存作为缓存很有必要，一段连续的内存空间

**free链表**中每一个节点都代表一个空闲的缓存页，在将磁盘中的页加载到Buffer Pool时，会从free链表中寻找空闲的缓存页。

在Buffer Pool中被修改的页称为脏页，脏页并不是立即刷新，而是被加入到**flush链表**中，待之后的某个时刻同步到磁盘上。

> **flush时机**
>
> 1. redo log写满
> 2. 内存不足，淘汰的是脏页，先把脏页fush到磁盘
> 3. 空闲时机，flush
> 4. mysql正常关闭

**LRU链表**

1）将LRU分为两个部分：

- 新生代(new sublist)
- 老生代(old sublist)

（2）新老生代收尾相连，即：新生代的尾(tail)连接着老生代的头(head)；

（3）新页（例如被预读的页）加入缓冲池时，只加入到老生代头部：

- 如果数据真正被读取（预读成功），才会加入到新生代的头部
- 如果数据没有被读取，则会比新生代里的“热数据页”更早被淘汰出缓冲池

### change buffer

**唯一索引普通索引选择难题**

> 唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。就需要将数据页读入内存当中，不能使用change buffer

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。

下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作

将change buffer中的操作应用到原数据页，得到最新结果的过程称为**merge**。

> merge时期：
>
> 1. 访问数据页
> 2. 后台线程定期merge
> 3. 数据库正常关闭merge