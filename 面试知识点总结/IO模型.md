#### 阻塞IO(BIO)

用户进程发起I/O操作后，内核进入数据准备阶段。数据还没准备好，用户进程就一直阻塞到数据从内核拷贝到用户内存，并且内核返回结果。

#### 非阻塞IO(NIO)

用户进程发起I/O操作，内核进入数据准备阶段，数据还没准备好，则会返回数据未准备好的结果，用户进程可以先去做别的事，之后不断轮询内核是否数据准备好。

#### 信号驱动IO

当用户进程发起IO操作，内核立即返回，进程继续运行，在内核准备好数据之后，通过信号通知用户线程。

#### 异步IO

与信号驱动IO不同的是，内核会把数据拷贝至用户内存之后通知用户进程整个操作完成（绑定一个数据处理的回调函数），用户进程通过回调函数处理数据。

#### IO多路复用

让单个进程可以监听多个文件描述符，一旦某一个文件描述符就绪，就会通知程序就行相应的读写操作。

> 文件描述符：Linux 系统中，把一切都看做是文件，当**进程打开现有文件或创建新文件**时，内核向进程返回一个文件描述符，**文件描述符就是内核为了高效管理已被打开的文件所创建的索引**，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。

**和多线程BIO相比，优势在于系统开销下，系统不需要创建和销毁线程，系统不需要维护这些线程**

select/poll/epoll 都是IO多路复用的具体实现。

##### select

每次调用 select 都需要把fd_set（监听的文件描述符列表），从用户态拷贝到核心态，并在核心态中遍历，等待一个或多个文件描述符变为就绪态

fd_set大小有所限制，为1024

fd_set 使用数组实现

##### poll

poll和select功能基本相同，没有对fd_set大小的限制

![image-20200816162154000](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200816162154000.png)

##### epoll

会将已注册的描述符维护在一颗红黑树上，当文件描述符就绪时，系统注册的回调函数就会被调用，把就绪的fd放到readylist里面。

epoll没有对文件描述符数量的限制

对多线程友好，不会像select，poll下文件描述符被另一个线程关闭后的不确定情况。

###### LT模式

只要句柄一直处于可用状态，就会一直通知用户。支持阻塞和非阻塞两种方式

###### ET模式

句柄在发生读写事件时只会通知用户一次

###### ET比LT更高效得原因

ET在通知用户后，就会把fd从就绪队列里删除。而LT通知用户后fd还在就绪链表中，随着fd的增多，就绪链表越大。下次epoll要通知用户时还需要遍历整个就绪链表。遍历的性能是线性，如果fd的数量非常多，就会带来比较显著的效率下降。同样数量的fd下，LT模式维护的就绪链表比ET的大。