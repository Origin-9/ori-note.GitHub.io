#### RPC 是什么

RPC：远程过程调用。通过RPC框架，使得我们可以像调用本地方法一样地调用远程机器上的方法。

1. 服务暴露（这里说的是暴露到远程）

   暴露到远程，也就是服务绑定了本机的端口后，用主机地址加端口来作为该服务的唯一标识。而服务消费者能够通过主机地址和端口来连接该服务提供者。

- 注册中心式：服务交由注册中心管理。

2. 服务引用

   服务引用的步骤大致可以分为两个步骤，分别是连接服务提供者以及创建接口的代理。

- 注册中心式：服务消费者通过注册中心来进行服务引用。也就是服务提供者的地址和端口从注册中心中获取，并且还可以保存服务消费者的地址和端口到注册中心，表示该服务消费者订阅了对应服务。当服务有一些变化时，注册中心能够通知服务消费者服务的变化。

3. 方法调用过程

- 服务消费者执行服务代理对象的一个方法，方法全限定名以及方法参数列表必须传输给服务提供者，因为方法全限定名用来定位在机器 B 中具体方法；
- 方法全限定名以及方法参数列表都将作为请求数据被传输到机器 B，而请求包将会被机器 A 和 B 约定好的统一序列化协议进行序列化和反序列化；
- 机器 B 解析请求数据，然后根据解析后的数据来定位需要调用的具体方法，执行对应的方法
-  机器 B 将返回结果反序列化后传递给最初的调用方，继续后续逻辑处理。

#### 核心内容

##### Netty

用Netty来搭建客户端和服务端，建立起两端之间的通信，为RPC准备好基础设施。

使用主从Reactor多线程模型，监听服务端ServerSocketChannel的Reactor使用了多线程的方式，接收客户端的TCP连接请求，同时将连接事件与其它事件的处理线程隔离，其它I/O事件用多线程来进行处理，防止I/O事件影响连接事件的处理。

通过扩展netty预置的解码器和编码器来实现自己的编解码器，解决TCP粘包，拆包问题。

##### 注册中心 Zookeeper

使用Zookeeper作为服务的注册中心，通过使用其 Watcher(事件监听器)，监听服务变化，向消费者更新服务

在项目中，主要使用ZooKeeper Java客户端 Curator提供的API进行Zookeeper的连接，节点的创建，更新，删除等操作

例如：CuratorFrameworkFactory.newClient()、client.create().withMode().forPath()、client().getData().forPath()

使用PathChildrenCacheListener，实现childEvent()，对服务进行监听，当服务发生变化时，客户端重新获取服务。

##### 动态代理

当客户端需要调用远程服务上的某一个方法前，**会在客户端中生成该服务接口的代理类**，这个代理类实现的接口和远程服务的接口一模一样，**用这个代理类来代理远程服务的功能**。

当客户端需要调用远程服务上的某一个方法时，就可以直接调用该代理类，但是真正执行方法的还是远程服务。

通过**使用CGLIB实现动态代理**，将**生成的动态代理类交给Spring IOC容器**。

因为服务方法的调用还是在远程服务中执行，在重写Intercept方法时，其中逻辑包括将执行的方法名，参数，参数值封装在POJO类request中，然后发送给远程服务，并等待接受执行结果。

##### 序列化

项目中使用到序列化的地方主要有两个，一个是将服务提供者提供的服务实例，序列化后保存在Zookeeper服务节点数据中，另一个是将客户端请求，以及服务端响应进行序列化，在网络中进行传输

项目中主要提供两种序列化方式，JDK原生序列化方式以及protostuff来实现序列化

##### 负载均衡

在服务端负载均衡和客户端负载均衡中选择客户端负载均衡策略

> 客户端负载均衡无需额外部署负载均衡器，并且也不需要进行请求转发或者代理，客户端可以直接和服务端进行相连通信，传输损耗相应减少。同样没有负载均衡器，也不存在负载均衡器的单点问题。

在项目中的实现比较简单，包括实现了服务端轮询负载均衡策略以及服务端随机负载均衡策略

##### Spring XML Schema 扩展机制

1. 创建 XML Schema 文件，由于该文件后缀名为 xsd
2. 编写实现一个或多个 `BeanDefinitionParser`
3. 编写`NamespaceHandler`实现类
4. 注册 `NamespaceHandler` 以及 XSD 文件

###### 创建 XSD 文件

XSD 文件，主要用来定义 XML 格式，用来验证 XML 合法性。

![image-20200814110920195](C:\Users\Ori\AppData\Roaming\Typora\typora-user-images\image-20200814110920195.png)

###### 实现 BeanDefinitionParser

真正解析 XML 动作在这里完成

在这里继承了`AbstractSimpleBeanDefinitionParser`，实现 doParser 方法即可。

###### 实现 NamespaceHandle

自定义 NamespaceHandler 要继承 `NamespaceHandlerSupport` 抽象类，实现 `init` 方法。

在这个方法中注册上面一步实现 `BeanDefinitionParser`。

###### 注册 XSD 以及 NamespaceHandle

两个配置文件，分别为 `spring.handlers`，`spring.schemas`。

`spring.schemas` 指定 XSD 文件路径。

`spring.handlers` 指定 `NamespaceHandler` 完整类名，既包含前面的包名。



